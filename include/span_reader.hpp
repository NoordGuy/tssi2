/*++
*    tssi - A library for parsing MPEG-2 and DVB Transport Streams
*
*    Copyright (C) 2017 - 2018 Martin Hoernig (goforcode.com)
*
*    This program is free software: you can redistribute it and/or modify
*    it under the terms of the GNU General Public License as published by
*    the Free Software Foundation, either version 3 of the License, or
*    (at your option) any later version.
*
*    This program is distributed in the hope that it will be useful,
*    but WITHOUT ANY WARRANTY; without even the implied warranty of
*    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
*    GNU General Public License for more details.
*
*    You should have received a copy of the GNU General Public License
*    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*
--*/

#pragma once

#include <gsl/span>
#include <string>
#include <chrono>

namespace tssi
{

template <size_t offset, size_t length>
class basic_reader {
public:
	typedef char element_type;
	static constexpr unsigned char error_value = 0x00;

	element_type operator()(gsl::span<const char> data, size_t index = 0, size_t offset2 = 0) const noexcept
	{
		return at(data, index, offset2);
	}

	static element_type at(gsl::span<const char> data, size_t index = 0, size_t offset2 = 0) noexcept
	{
		const ptrdiff_t position = offset + index * length + offset2;		
		if (position >= data.size())
			return static_cast<element_type>(error_value);
		else
			return data[position];
	}
};

template <size_t offset, class count_reference, ptrdiff_t count_reference_offset, size_t length>
class span_reader {
public:
	typedef gsl::span<const char> element_type;

	element_type operator()(gsl::span<const char> data, size_t index = 0, size_t offset2 = 0) const noexcept
	{
		return at(data, index, offset2);
	}

	static element_type at(gsl::span<const char> data, size_t index = 0, size_t offset2 = 0) noexcept
	{
		const ptrdiff_t ref = static_cast<size_t>(count_reference::at(data, 0)) + count_reference_offset;
		const ptrdiff_t off = offset + index * length + offset2;
		if (off + ref > data.size())
			return data.subspan(data.size());
		else
			return data.subspan(off, ref);
		// index of count_reference always == 0
	}

};

typedef ptrdiff_t(*tssi_size_t)(gsl::span<const char> data);
template<tssi_size_t iteration_stride, bool is_const>
class range_span_iterator {
	typedef gsl::span<const char> Span;
	using element_type = typename Span::element_type;
	using index_type = std::ptrdiff_t;
	using reference = std::conditional_t<is_const, const Span, Span>&;
	using pointer = std::add_pointer_t<reference>;

	static const element_type value = 0;

public:
	constexpr range_span_iterator() : span_(&value, static_cast<index_type>(0)) { }

	range_span_iterator(const gsl::span<const char> span) noexcept : span_(span) { }

	friend class range_span_iterator<iteration_stride, true>;
	constexpr range_span_iterator(const range_span_iterator<iteration_stride, false>& other) noexcept :
	range_span_iterator(other.span_) { }

	constexpr range_span_iterator(range_span_iterator&&) noexcept = default;

	constexpr range_span_iterator& operator++() noexcept
	{
		// get loop size
		//iteration_stride loop;
		//auto size = loop.size(span_);
		auto size = iteration_stride(span_);

		// go one loop length ahead
		if (size <= span_.length())
			span_ = span_.subspan(size);
		else
			span_ = span_.subspan(span_.size());

		return *this;
	}

	constexpr range_span_iterator operator++(int) noexcept
	{
		auto ret = *this;
		++(*this);
		return ret;
	}

	constexpr reference operator*()  noexcept
	{
		return (span_);
	}

	constexpr reference operator*() const noexcept
	{
		return (span_);
	}

	constexpr pointer operator->() noexcept
	{
		return &(span_);
	}

	constexpr pointer operator->() const noexcept
	{
		return &(span_);
	}

	constexpr friend bool operator==(const range_span_iterator& lhs, const range_span_iterator& rhs) noexcept
	{
		return (lhs.size() == rhs.size()) && lhs.span_ == rhs.span_;
	}

	constexpr friend bool operator!=(const range_span_iterator& lhs, const range_span_iterator& rhs) noexcept
	{
		return !(lhs == rhs);
	}

	constexpr index_type length() const noexcept { return size(); }
	constexpr index_type size() const noexcept { return span_.size(); }
	constexpr index_type lengthchars() const noexcept { return sizechars(); }
	constexpr index_type sizechars() const noexcept { return span_.sizechars(); }
	constexpr bool empty() const noexcept { return size() == 0; }

	void swap(range_span_iterator& rhs)
	{
		std::swap(span_, rhs.span_);
	}

private:
	Span span_;
};

template<tssi_size_t iteration_stride>
class range_span {
	typedef gsl::span<const char> Span;
	using element_type = typename Span::element_type;
	using index_type = std::ptrdiff_t;
	using reference = element_type&;

public:
	using iterator = range_span_iterator<iteration_stride, false>;
	using const_iterator = range_span_iterator<iteration_stride, true>;

	range_span(Span data) noexcept : data_(data) { }
	constexpr range_span(range_span&&) noexcept = default;

	iterator begin() { return { data_ }; }
	iterator end() { return {}; }

	const_iterator cbegin() { return { data_ }; }
	const_iterator cend() { return {}; }

	constexpr index_type length() const noexcept { return size(); }
	constexpr index_type size() const noexcept { return data_.size(); }
	constexpr index_type lengthchars() const noexcept { return sizechars(); }
	constexpr index_type sizechars() const noexcept { return data_.sizechars(); }
	constexpr bool empty() const noexcept { return size() == 0; }

	operator Span() const noexcept { return data_; }
	Span data() const noexcept { return data_; }
	reference operator[](index_type idx) const noexcept { return data_[idx]; }

	constexpr reference at(index_type idx) const noexcept { return this->operator[](idx); }
	constexpr reference operator()(index_type idx) const noexcept { return this->operator[](idx); }

	constexpr friend bool operator==(const range_span& lhs, const range_span& rhs) noexcept
	{
		return lhs.data_ == rhs.data_;
	}

	constexpr friend bool operator!=(const range_span& lhs, const range_span& rhs) noexcept
	{
		return !(lhs == rhs);
	}

private:
	Span data_;
};

template<class span_reader, tssi_size_t iteration_stride>
class iterable_span {
public:
	typedef range_span<iteration_stride> element_type;

	element_type operator()(gsl::span<const char> data, size_t index = 0) const noexcept
	{
		return at(data, index);
	}

	static element_type at(gsl::span<const char> data, size_t index = 0) noexcept
	{
		return element_type(span_reader::at(data, index));
	}
};

template<class count_reference_a, class count_reference_b>
class reference_sum {
public:
	typedef ptrdiff_t element_type;

	element_type operator()(gsl::span<const char> data, size_t index = 0) const noexcept
	{
		return at(data, index);
	}

	static element_type at(gsl::span<const char> data, size_t index = 0) noexcept
	{
		index;
		return static_cast<ptrdiff_t>(count_reference_a::at(data, 0)) + static_cast<ptrdiff_t>(count_reference_b::at(data, 0));
	}

};

template<class count_reference_a, class count_reference_b>
class reference_difference {
public:
	typedef ptrdiff_t element_type;

	element_type operator()(gsl::span<const char> data, size_t index = 0) const noexcept
	{
		return at(data, index);
	}

	static element_type at(gsl::span<const char> data, size_t index = 0) noexcept
	{
		index;
		return static_cast<ptrdiff_t>(count_reference_a::at(data, 0)) - static_cast<ptrdiff_t>(count_reference_b::at(data, 0));
	}

};


template <class reader, class shift_reference>
class combined_reader {
public:
	typedef typename reader::element_type element_type;

	element_type operator()(gsl::span<const char> data, size_t index = 0, size_t offset2 = 0) const noexcept
	{
		return at(data, index, offset2);
	}

	static element_type at(gsl::span<const char> data, size_t index = 0, size_t offset2 = 0) noexcept
	{
		return reader::at(data, index, offset2 + shift_reference::at(data, 0));
		// index of shift_reference always == 0
	}
};


template<class reader, size_t position>
class bit_reader {
public:
	typedef bool element_type;

	element_type operator()(gsl::span<const char> data, size_t index = 0) const noexcept
	{
		return at(data, index);
	}

	static element_type at(gsl::span<const char> data, size_t index = 0) noexcept
	{
		return (static_cast<unsigned char>(reader::at(data, index)) & (1 << position));
	}
};


template<class T, class reader, size_t stride = sizeof(T)>
class endian_aware_value_reader {
public:
	typedef T element_type;

	element_type operator()(gsl::span<const char> data, size_t index = 0) const noexcept
	{
		return at(data, index);
	}

	static element_type at(gsl::span<const char> data, size_t index = 0) noexcept
	{
		element_type result{};
		for (size_t i = 0; i < stride; ++i)
#ifdef __BIG_ENDIAN
			result += static_cast<T>(static_cast<unsigned char>(reader::at(data, index, i))) << (i << 3);
#else // __BIG_ENDIAN
			result += static_cast<T>(static_cast<unsigned char>(reader::at(data, index, i))) << ((stride - i - 1) << 3);
#endif // __BIG_ENDIAN

		return result;
	}
};

template<class value_reader, uint_fast64_t mask_bits, uint_fast64_t shift_right>
class mask_shift
{
public:
	typedef typename value_reader::element_type element_type;

	element_type operator()(gsl::span<const char> data, size_t index = 0) const noexcept
	{
		return at(data, index);
	}

	static element_type at(gsl::span<const char> data, size_t index = 0) noexcept
	{
		return (value_reader::at(data, index) & static_cast<element_type>(mask_bits)) >> shift_right;
	}

};

template<class value_reader>
class time_convert
{
public:
	typedef time_t element_type;

	element_type operator()(gsl::span<const char> data, size_t index = 0) const
	{
		return at(data, index);
	}

	static element_type at(gsl::span<const char> data, size_t index = 0)
	{
		auto value = value_reader::at(data, index);
		Expects(sizeof(value) >= 8);
		tm t{};

		t.tm_hour = bcd_dec((value & 0xff0000) >> 16);
		t.tm_min = bcd_dec((value & 0xff00) >> 8);
		t.tm_sec = bcd_dec(value & 0xff);

		auto mjd = static_cast<int> (value >> 24);
		auto y1 = static_cast<int> ((mjd - 15078.2) / 365.25);
		auto m1 = static_cast<int> ((mjd - 14956.1 - static_cast<int> (y1 * 365.25)) / 30.6001);
		t.tm_mday = mjd - 14956 - static_cast<int> (y1 * 365.25) - static_cast<int> (m1 * 30.6001);
		auto k = 0;
		if (m1 == 14 || m1 == 15) k = 1;
		t.tm_year = y1 + k;
		t.tm_mon = m1 - 2 - k * 12;

		return mktime(&t); // no-throw guarantee
	}
private:
	static int bcd_dec(uint_fast64_t hex) noexcept {
		if (((hex & 0xf0) >> 4) >= 10)
			return 0;
		if ((hex & 0xf) >= 10)
			return 0;
		return ((hex & 0xf0) >> 4) * 10 + (hex & 0xf);
	}

};

template<class value_reader>
class duration_convert
{
public:
	typedef std::chrono::seconds element_type;

	element_type operator()(gsl::span<const char> data, size_t index = 0) const
	{
		return at(data, index);
	}

	static element_type at(gsl::span<const char> data, size_t index = 0)
	{
		auto value = value_reader::at(data, index);
		Expects(sizeof(value) >= 4);

		element_type result{};

		result += std::chrono::hours(bcd_dec((value & 0xff0000) >> 16));
		result += std::chrono::minutes(bcd_dec((value & 0xff00) >> 8));
		result += std::chrono::seconds(bcd_dec(value & 0xff));

		return result;
	}
private:
	static constexpr int bcd_dec(uint_fast64_t hex) noexcept {
		if (((hex & 0xf0) >> 4) >= 10)
			return 0;
		if ((hex & 0xf) >= 10)
			return 0;
		return ((hex & 0xf0) >> 4) * 10 + (hex & 0xf);
	}

};

template<class value_reader, size_t digits = sizeof(value_reader::element_type) * 2>
class bcd_convert
{
public:
	typedef typename value_reader::element_type element_type;

	element_type operator()(gsl::span<const char> data, size_t index = 0) const noexcept
	{
		return at(data, index);
	}

	static element_type at(gsl::span<const char> data, size_t index = 0) noexcept
	{
		auto value = value_reader::at(data, index);
		element_type result{};
		for (auto i = 0u; i < digits; ++i) {
			result += static_cast<element_type>(((value >> (i << 2)) & 0xf) * ipow(10, i));
		}
		return result;
	}
private:
	static unsigned ipow(unsigned base, unsigned exp) noexcept
	{
		unsigned result = 1;
		while (exp)
		{
			if (exp & 1)
				result *= base;
			exp >>= 1;
			base *= base;
		}

		return result;
	}
};

namespace {

	static const uint_least16_t cp6937_table[256] = {
		// 0	1		2		3		4		5		6		7		8		9		A		B		C		D		E		F 2nd nibble
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, // 0 1st nibble
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, // 1 
		0x0020, 0x0021, 0x0022, 0x0023, 0x0024, 0x0025, 0x0026, 0x0027, 0x0028, 0x0029, 0x002a, 0x002b, 0x002c, 0x002d, 0x002e, 0x002f, // 2
		0x0030, 0x0031, 0x0032, 0x0033, 0x0034, 0x0035, 0x0036, 0x0037, 0x0038, 0x0039, 0x003a, 0x003b, 0x003c, 0x003d, 0x003e, 0x003f, // 3
		0x0040, 0x0041, 0x0042, 0x0043, 0x0044, 0x0045, 0x0046, 0x0047, 0x0048, 0x0049, 0x004a, 0x004b, 0x004c, 0x004d, 0x004e, 0x004f, // 4
		0x0050, 0x0051, 0x0052, 0x0053, 0x0054, 0x0055, 0x0056, 0x0057, 0x0058, 0x0059, 0x005a, 0x005b, 0x005c, 0x005d, 0x005e, 0x005f, // 5
		0x0060, 0x0061, 0x0062, 0x0063, 0x0064, 0x0065, 0x0066, 0x0067, 0x0068, 0x0069, 0x006a, 0x006b, 0x006c, 0x006d, 0x006e, 0x006f, // 6
		0x0070, 0x0071, 0x0072, 0x0073, 0x0074, 0x0075, 0x0076, 0x0077, 0x0078, 0x0079, 0x007a, 0x007b, 0x007c, 0x007d, 0x007e, 0x0000, // 7
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, // 8
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, // 9
		0x00a0, 0x00a1, 0x00a2, 0x00a3, 0x20ac, 0x00a5, 0x0000, 0x00a7, 0x00a4, 0x2018, 0x201c, 0x00ab, 0x2190, 0x2191, 0x2192, 0x2193, // A
		0x00b0, 0x00b1, 0x00b2, 0x00b3, 0x00d7, 0x00b5, 0x00b6, 0x00b7, 0x00f7, 0x2019, 0x201d, 0x00bb, 0x00bc, 0x00bd, 0x00be, 0x00bf, // B
		0x0000, 0x0300, 0x0301, 0x0302, 0x0303, 0x0304, 0x0306, 0x0307, 0x0308, 0x0000, 0x030a, 0x0327, 0x0000, 0x030b, 0x0328, 0x030c, // C
		0x2015, 0x00b9, 0x00ae, 0x00a9, 0x2122, 0x266a, 0x00ac, 0x00a6, 0x0000, 0x0000, 0x0000, 0x0000, 0x215b, 0x215c, 0x215d, 0x215e, // D
		0x2126, 0x00c6, 0x0110, 0x00aa, 0x0126, 0x0000, 0x0132, 0x013f, 0x0141, 0x00d8, 0x0152, 0x00ba, 0x00de, 0x0166, 0x014a, 0x0149, // E
		0x0138, 0x00e6, 0x0111, 0x00f0, 0x0127, 0x0131, 0x0133, 0x0140, 0x0142, 0x00f8, 0x0153, 0x00df, 0x00fe, 0x0167, 0x014b, 0x00ad  // F
	};

	static const uint_least16_t cp8859_5_table[256] = {
		// 0	1		2		3		4		5		6		7		8		9		A		B		C		D		E		F 2nd nibble
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, // 0 1st nibble
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, // 1 
		0x0020, 0x0021, 0x0022, 0x0023, 0x0024, 0x0025, 0x0026, 0x0027, 0x0028, 0x0029, 0x002a, 0x002b, 0x002c, 0x002d, 0x002e, 0x002f, // 2
		0x0030, 0x0031, 0x0032, 0x0033, 0x0034, 0x0035, 0x0036, 0x0037, 0x0038, 0x0039, 0x003a, 0x003b, 0x003c, 0x003d, 0x003e, 0x003f, // 3
		0x0040, 0x0041, 0x0042, 0x0043, 0x0044, 0x0045, 0x0046, 0x0047, 0x0048, 0x0049, 0x004a, 0x004b, 0x004c, 0x004d, 0x004e, 0x004f, // 4
		0x0050, 0x0051, 0x0052, 0x0053, 0x0054, 0x0055, 0x0056, 0x0057, 0x0058, 0x0059, 0x005a, 0x005b, 0x005c, 0x005d, 0x005e, 0x005f, // 5
		0x0060, 0x0061, 0x0062, 0x0063, 0x0064, 0x0065, 0x0066, 0x0067, 0x0068, 0x0069, 0x006a, 0x006b, 0x006c, 0x006d, 0x006e, 0x006f, // 6
		0x0070, 0x0071, 0x0072, 0x0073, 0x0074, 0x0075, 0x0076, 0x0077, 0x0078, 0x0079, 0x007a, 0x007b, 0x007c, 0x007d, 0x007e, 0x0000, // 7
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, // 8
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, // 9
		0x00a0, 0x0401, 0x0402, 0x0403, 0x0404, 0x0405, 0x0406, 0x0407, 0x0408, 0x0409, 0x040a, 0x040b, 0x040c, 0x00ad, 0x040e, 0x040f, // A
		0x0410, 0x0411, 0x0412, 0x0413, 0x0414, 0x0415, 0x0416, 0x0417, 0x0418, 0x0419, 0x041a, 0x041b, 0x041c, 0x041d, 0x041e, 0x041f, // B
		0x0420, 0x0421, 0x0422, 0x0423, 0x0424, 0x0425, 0x0426, 0x0427, 0x0428, 0x0429, 0x042a, 0x042b, 0x042c, 0x042d, 0x042e, 0x042f, // C
		0x0430, 0x0431, 0x0432, 0x0433, 0x0434, 0x0435, 0x0436, 0x0437, 0x0438, 0x0439, 0x043a, 0x043b, 0x043c, 0x043d, 0x043e, 0x043f, // D
		0x0440, 0x0441, 0x0442, 0x0443, 0x0444, 0x0445, 0x0446, 0x0447, 0x0448, 0x0449, 0x044a, 0x044b, 0x044c, 0x044d, 0x044e, 0x044f, // E
		0x2116, 0x0451, 0x0452, 0x0453, 0x0454, 0x0455, 0x0456, 0x0457, 0x0458, 0x0459, 0x045a, 0x045b, 0x045c, 0x00a7, 0x045e, 0x045f  // F
	};

	static const uint_least16_t cp8859_6_table[256] = {
		// 0	1		2		3		4		5		6		7		8		9		A		B		C		D		E		F 2nd nibble
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, // 0 1st nibble
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, // 1 
		0x0020, 0x0021, 0x0022, 0x0023, 0x0024, 0x0025, 0x0026, 0x0027, 0x0028, 0x0029, 0x002a, 0x002b, 0x002c, 0x002d, 0x002e, 0x002f, // 2
		0x0030, 0x0031, 0x0032, 0x0033, 0x0034, 0x0035, 0x0036, 0x0037, 0x0038, 0x0039, 0x003a, 0x003b, 0x003c, 0x003d, 0x003e, 0x003f, // 3
		0x0040, 0x0041, 0x0042, 0x0043, 0x0044, 0x0045, 0x0046, 0x0047, 0x0048, 0x0049, 0x004a, 0x004b, 0x004c, 0x004d, 0x004e, 0x004f, // 4
		0x0050, 0x0051, 0x0052, 0x0053, 0x0054, 0x0055, 0x0056, 0x0057, 0x0058, 0x0059, 0x005a, 0x005b, 0x005c, 0x005d, 0x005e, 0x005f, // 5
		0x0060, 0x0061, 0x0062, 0x0063, 0x0064, 0x0065, 0x0066, 0x0067, 0x0068, 0x0069, 0x006a, 0x006b, 0x006c, 0x006d, 0x006e, 0x006f, // 6
		0x0070, 0x0071, 0x0072, 0x0073, 0x0074, 0x0075, 0x0076, 0x0077, 0x0078, 0x0079, 0x007a, 0x007b, 0x007c, 0x007d, 0x007e, 0x0000, // 7
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, // 8
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, // 9
		0x00a0, 0x0000, 0x0000, 0x0000, 0x00a4, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x060c, 0x00ad, 0x0000, 0x0000, // A
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x061b, 0x0000, 0x0000, 0x0000, 0x061f, // B
		0x0000, 0x0621, 0x0622, 0x0623, 0x0624, 0x0625, 0x0626, 0x0627, 0x0628, 0x0629, 0x062a, 0x062b, 0x062c, 0x062d, 0x062e, 0x062f, // C
		0x0630, 0x0631, 0x0632, 0x0633, 0x0634, 0x0635, 0x0636, 0x0637, 0x0638, 0x0639, 0x063a, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, // D
		0x0640, 0x0641, 0x0642, 0x0643, 0x0644, 0x0645, 0x0646, 0x0647, 0x0648, 0x0649, 0x064a, 0x064b, 0x064c, 0x064d, 0x064e, 0x064f, // E
		0x0650, 0x0651, 0x0652, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000  // F
	};

	static const uint_least16_t cp8859_7_table[256] = {
		// 0	1		2		3		4		5		6		7		8		9		A		B		C		D		E		F 2nd nibble
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, // 0 1st nibble
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, // 1 
		0x0020, 0x0021, 0x0022, 0x0023, 0x0024, 0x0025, 0x0026, 0x0027, 0x0028, 0x0029, 0x002a, 0x002b, 0x002c, 0x002d, 0x002e, 0x002f, // 2
		0x0030, 0x0031, 0x0032, 0x0033, 0x0034, 0x0035, 0x0036, 0x0037, 0x0038, 0x0039, 0x003a, 0x003b, 0x003c, 0x003d, 0x003e, 0x003f, // 3
		0x0040, 0x0041, 0x0042, 0x0043, 0x0044, 0x0045, 0x0046, 0x0047, 0x0048, 0x0049, 0x004a, 0x004b, 0x004c, 0x004d, 0x004e, 0x004f, // 4
		0x0050, 0x0051, 0x0052, 0x0053, 0x0054, 0x0055, 0x0056, 0x0057, 0x0058, 0x0059, 0x005a, 0x005b, 0x005c, 0x005d, 0x005e, 0x005f, // 5
		0x0060, 0x0061, 0x0062, 0x0063, 0x0064, 0x0065, 0x0066, 0x0067, 0x0068, 0x0069, 0x006a, 0x006b, 0x006c, 0x006d, 0x006e, 0x006f, // 6
		0x0070, 0x0071, 0x0072, 0x0073, 0x0074, 0x0075, 0x0076, 0x0077, 0x0078, 0x0079, 0x007a, 0x007b, 0x007c, 0x007d, 0x007e, 0x0000, // 7
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, // 8
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, // 9
		0x00a0, 0x2018, 0x2019, 0x00a3, 0x20ac, 0x20af, 0x00a6, 0x00a7, 0x00a8, 0x00a9, 0x037a, 0x00ab, 0x00ac, 0x00ad, 0x0000, 0x2015, // A
		0x00b0, 0x00b1, 0x00b2, 0x00b3, 0x0384, 0x0385, 0x0386, 0x0387, 0x0388, 0x0389, 0x038a, 0x00bb, 0x038c, 0x00bd, 0x038e, 0x038f, // B
		0x0390, 0x0391, 0x0392, 0x0393, 0x0394, 0x0395, 0x0396, 0x0397, 0x0398, 0x0399, 0x039a, 0x039b, 0x039c, 0x039d, 0x039e, 0x039f, // C
		0x03a0, 0x03a1, 0x0000, 0x03a3, 0x03a4, 0x03a5, 0x03a6, 0x03a7, 0x03a8, 0x03a9, 0x03aa, 0x03ab, 0x03ac, 0x03ad, 0x03ae, 0x03af, // D
		0x03b0, 0x03b1, 0x03b2, 0x03b3, 0x03b4, 0x03b5, 0x03b6, 0x03b7, 0x03b8, 0x03b9, 0x03ba, 0x03bb, 0x03bc, 0x03bd, 0x03be, 0x03bf, // E
		0x03c0, 0x03c1, 0x03c2, 0x03c3, 0x03c4, 0x03c5, 0x03c6, 0x03c7, 0x03c8, 0x03c9, 0x03ca, 0x03cb, 0x03cc, 0x03cd, 0x03ce, 0x0000  // F
	};

	static const uint_least16_t cp8859_8_table[256] = {
		// 0	1		2		3		4		5		6		7		8		9		A		B		C		D		E		F 2nd nibble
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, // 0 1st nibble
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, // 1 
		0x0020, 0x0021, 0x0022, 0x0023, 0x0024, 0x0025, 0x0026, 0x0027, 0x0028, 0x0029, 0x002a, 0x002b, 0x002c, 0x002d, 0x002e, 0x002f, // 2
		0x0030, 0x0031, 0x0032, 0x0033, 0x0034, 0x0035, 0x0036, 0x0037, 0x0038, 0x0039, 0x003a, 0x003b, 0x003c, 0x003d, 0x003e, 0x003f, // 3
		0x0040, 0x0041, 0x0042, 0x0043, 0x0044, 0x0045, 0x0046, 0x0047, 0x0048, 0x0049, 0x004a, 0x004b, 0x004c, 0x004d, 0x004e, 0x004f, // 4
		0x0050, 0x0051, 0x0052, 0x0053, 0x0054, 0x0055, 0x0056, 0x0057, 0x0058, 0x0059, 0x005a, 0x005b, 0x005c, 0x005d, 0x005e, 0x005f, // 5
		0x0060, 0x0061, 0x0062, 0x0063, 0x0064, 0x0065, 0x0066, 0x0067, 0x0068, 0x0069, 0x006a, 0x006b, 0x006c, 0x006d, 0x006e, 0x006f, // 6
		0x0070, 0x0071, 0x0072, 0x0073, 0x0074, 0x0075, 0x0076, 0x0077, 0x0078, 0x0079, 0x007a, 0x007b, 0x007c, 0x007d, 0x007e, 0x0000, // 7
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, // 8
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, // 9
		0x00a0, 0x0000, 0x00a2, 0x00a3, 0x00a4, 0x00a5, 0x00a6, 0x00a7, 0x00a8, 0x00a9, 0x00d7, 0x00ab, 0x00ac, 0x00ad, 0x00ae, 0x00af, // A
		0x00b0, 0x00b1, 0x00b2, 0x00b3, 0x00b4, 0x00b5, 0x00b6, 0x00b7, 0x00b8, 0x00b9, 0x00f7, 0x00bb, 0x00bc, 0x00bd, 0x00be, 0x0000, // B
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, // C
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x2017, // D
		0x05d0, 0x05d1, 0x05d2, 0x05d3, 0x05d4, 0x05d5, 0x05d6, 0x05d7, 0x05d8, 0x05d9, 0x05da, 0x05db, 0x05dc, 0x05dd, 0x05de, 0x05df, // E
		0x05e0, 0x05e1, 0x05e2, 0x05e3, 0x05e4, 0x05e5, 0x05e6, 0x05e7, 0x05e8, 0x05e9, 0x05ea, 0x0000, 0x0000, 0x200e, 0x200f, 0x0000  // F
	};

	static const uint_least16_t cp8859_9_table[256] = {
		// 0	1		2		3		4		5		6		7		8		9		A		B		C		D		E		F 2nd nibble
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, // 0 1st nibble
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, // 1 
		0x0020, 0x0021, 0x0022, 0x0023, 0x0024, 0x0025, 0x0026, 0x0027, 0x0028, 0x0029, 0x002a, 0x002b, 0x002c, 0x002d, 0x002e, 0x002f, // 2
		0x0030, 0x0031, 0x0032, 0x0033, 0x0034, 0x0035, 0x0036, 0x0037, 0x0038, 0x0039, 0x003a, 0x003b, 0x003c, 0x003d, 0x003e, 0x003f, // 3
		0x0040, 0x0041, 0x0042, 0x0043, 0x0044, 0x0045, 0x0046, 0x0047, 0x0048, 0x0049, 0x004a, 0x004b, 0x004c, 0x004d, 0x004e, 0x004f, // 4
		0x0050, 0x0051, 0x0052, 0x0053, 0x0054, 0x0055, 0x0056, 0x0057, 0x0058, 0x0059, 0x005a, 0x005b, 0x005c, 0x005d, 0x005e, 0x005f, // 5
		0x0060, 0x0061, 0x0062, 0x0063, 0x0064, 0x0065, 0x0066, 0x0067, 0x0068, 0x0069, 0x006a, 0x006b, 0x006c, 0x006d, 0x006e, 0x006f, // 6
		0x0070, 0x0071, 0x0072, 0x0073, 0x0074, 0x0075, 0x0076, 0x0077, 0x0078, 0x0079, 0x007a, 0x007b, 0x007c, 0x007d, 0x007e, 0x0000, // 7
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, // 8
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, // 9
		0x00a0, 0x00a1, 0x00a2, 0x00a3, 0x00a4, 0x00a5, 0x00a6, 0x00a7, 0x00a8, 0x00a9, 0x00d7, 0x00ab, 0x00ac, 0x00ad, 0x00ae, 0x00af, // A
		0x00b0, 0x00b1, 0x00b2, 0x00b3, 0x00b4, 0x00b5, 0x00b6, 0x00b7, 0x00b8, 0x00b9, 0x00f7, 0x00bb, 0x00bc, 0x00bd, 0x00be, 0x00bf, // B
		0x00c0, 0x00c1, 0x00c2, 0x00c3, 0x00c4, 0x00c5, 0x00c6, 0x00c7, 0x00c8, 0x00c9, 0x00ca, 0x00cb, 0x00cc, 0x00cd, 0x00ce, 0x00cf, // C
		0x011e, 0x00d1, 0x00d2, 0x00d3, 0x00d4, 0x00d5, 0x00d6, 0x00d7, 0x00d8, 0x00d9, 0x00da, 0x00db, 0x00dc, 0x0130, 0x015e, 0x00df, // D
		0x00e0, 0x00e1, 0x00e2, 0x00e3, 0x00e4, 0x00e5, 0x00e6, 0x00e7, 0x00e8, 0x00e9, 0x00ea, 0x00eb, 0x00ec, 0x00ed, 0x00ee, 0x00ef, // E
		0x011f, 0x00f1, 0x00f2, 0x00f3, 0x00f4, 0x00f5, 0x00f6, 0x00f7, 0x00f8, 0x00f9, 0x00fa, 0x00fb, 0x00fc, 0x0131, 0x015f, 0x00ff  // F
	};

	static const uint_least16_t cp8859_10_table[256] = {
		// 0	1		2		3		4		5		6		7		8		9		A		B		C		D		E		F 2nd nibble
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, // 0 1st nibble
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, // 1 
		0x0020, 0x0021, 0x0022, 0x0023, 0x0024, 0x0025, 0x0026, 0x0027, 0x0028, 0x0029, 0x002a, 0x002b, 0x002c, 0x002d, 0x002e, 0x002f, // 2
		0x0030, 0x0031, 0x0032, 0x0033, 0x0034, 0x0035, 0x0036, 0x0037, 0x0038, 0x0039, 0x003a, 0x003b, 0x003c, 0x003d, 0x003e, 0x003f, // 3
		0x0040, 0x0041, 0x0042, 0x0043, 0x0044, 0x0045, 0x0046, 0x0047, 0x0048, 0x0049, 0x004a, 0x004b, 0x004c, 0x004d, 0x004e, 0x004f, // 4
		0x0050, 0x0051, 0x0052, 0x0053, 0x0054, 0x0055, 0x0056, 0x0057, 0x0058, 0x0059, 0x005a, 0x005b, 0x005c, 0x005d, 0x005e, 0x005f, // 5
		0x0060, 0x0061, 0x0062, 0x0063, 0x0064, 0x0065, 0x0066, 0x0067, 0x0068, 0x0069, 0x006a, 0x006b, 0x006c, 0x006d, 0x006e, 0x006f, // 6
		0x0070, 0x0071, 0x0072, 0x0073, 0x0074, 0x0075, 0x0076, 0x0077, 0x0078, 0x0079, 0x007a, 0x007b, 0x007c, 0x007d, 0x007e, 0x0000, // 7
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, // 8
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, // 9
		0x00a0, 0x0104, 0x0112, 0x0122, 0x012a, 0x0128, 0x0136, 0x00a7, 0x013b, 0x0110, 0x0160, 0x0166, 0x017d, 0x00ad, 0x016a, 0x014a, // A
		0x00b0, 0x0105, 0x0113, 0x0123, 0x012b, 0x0129, 0x0137, 0x00b7, 0x013c, 0x0111, 0x0161, 0x0167, 0x017e, 0x2015, 0x016b, 0x014b, // B
		0x0100, 0x00c1, 0x00c2, 0x00c3, 0x00c4, 0x00c5, 0x00c6, 0x012e, 0x010c, 0x00c9, 0x0118, 0x00cb, 0x0116, 0x00cd, 0x00ce, 0x00cf, // C
		0x00d0, 0x0145, 0x014c, 0x00d3, 0x00d4, 0x00d5, 0x00d6, 0x0168, 0x00d8, 0x0172, 0x00da, 0x00db, 0x00dc, 0x00dd, 0x00de, 0x00df, // D
		0x0101, 0x00e1, 0x00e2, 0x00e3, 0x00e4, 0x00e5, 0x00e6, 0x012f, 0x010d, 0x00e9, 0x0119, 0x00eb, 0x0117, 0x00ed, 0x00ee, 0x00ef, // E
		0x00f0, 0x0146, 0x014d, 0x00f3, 0x00f4, 0x00f5, 0x00f6, 0x0169, 0x00f8, 0x0173, 0x00fa, 0x00fb, 0x00fc, 0x00fd, 0x00fe, 0x0138  // F
	};

	static const uint_least16_t cp8859_11_table[256] = {
		// 0	1		2		3		4		5		6		7		8		9		A		B		C		D		E		F 2nd nibble
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, // 0 1st nibble
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, // 1 
		0x0020, 0x0021, 0x0022, 0x0023, 0x0024, 0x0025, 0x0026, 0x0027, 0x0028, 0x0029, 0x002a, 0x002b, 0x002c, 0x002d, 0x002e, 0x002f, // 2
		0x0030, 0x0031, 0x0032, 0x0033, 0x0034, 0x0035, 0x0036, 0x0037, 0x0038, 0x0039, 0x003a, 0x003b, 0x003c, 0x003d, 0x003e, 0x003f, // 3
		0x0040, 0x0041, 0x0042, 0x0043, 0x0044, 0x0045, 0x0046, 0x0047, 0x0048, 0x0049, 0x004a, 0x004b, 0x004c, 0x004d, 0x004e, 0x004f, // 4
		0x0050, 0x0051, 0x0052, 0x0053, 0x0054, 0x0055, 0x0056, 0x0057, 0x0058, 0x0059, 0x005a, 0x005b, 0x005c, 0x005d, 0x005e, 0x005f, // 5
		0x0060, 0x0061, 0x0062, 0x0063, 0x0064, 0x0065, 0x0066, 0x0067, 0x0068, 0x0069, 0x006a, 0x006b, 0x006c, 0x006d, 0x006e, 0x006f, // 6
		0x0070, 0x0071, 0x0072, 0x0073, 0x0074, 0x0075, 0x0076, 0x0077, 0x0078, 0x0079, 0x007a, 0x007b, 0x007c, 0x007d, 0x007e, 0x0000, // 7
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, // 8
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, // 9
		0x00a0, 0x0e01, 0x0e02, 0x0e03, 0x0e04, 0x0e05, 0x0e06, 0x0e07, 0x0e08, 0x0e09, 0x0e0a, 0x0e0b, 0x0e0c, 0x0e0d, 0x0e0e, 0x0e0f, // A
		0x0e10, 0x0e11, 0x0e12, 0x0e13, 0x0e14, 0x0e15, 0x0e16, 0x0e17, 0x0e18, 0x0e19, 0x0e1a, 0x0e1b, 0x0e1c, 0x0e1d, 0x0e1e, 0x0e1f, // B
		0x0e20, 0x0e21, 0x0e22, 0x0e23, 0x0e24, 0x0e25, 0x0e26, 0x0e27, 0x0e28, 0x0e29, 0x0e2a, 0x0e2b, 0x0e2c, 0x0e2d, 0x0e2e, 0x0e2f, // C
		0x0e30, 0x0e31, 0x0e32, 0x0e33, 0x0e34, 0x0e35, 0x0e36, 0x0e37, 0x0e38, 0x0e39, 0x0e3a, 0x0030, 0x0000, 0x0000, 0x0000, 0x0e3f, // D
		0x0e40, 0x0e41, 0x0e42, 0x0e43, 0x0e44, 0x0e45, 0x0e46, 0x0e47, 0x0e48, 0x0e49, 0x0e4a, 0x0e4b, 0x0e4c, 0x0e4d, 0x0e4e, 0x0e4f, // E
		0x0e50, 0x0e51, 0x0e52, 0x0e53, 0x0e54, 0x0e55, 0x0e56, 0x0e57, 0x0e58, 0x0e59, 0x0e5a, 0x0e5b, 0x0000, 0x0000, 0x0000, 0x0000  // F
	};

	static const uint_least16_t cp8859_13_table[256] = {
		// 0	1		2		3		4		5		6		7		8		9		A		B		C		D		E		F 2nd nibble
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, // 0 1st nibble
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, // 1 
		0x0020, 0x0021, 0x0022, 0x0023, 0x0024, 0x0025, 0x0026, 0x0027, 0x0028, 0x0029, 0x002a, 0x002b, 0x002c, 0x002d, 0x002e, 0x002f, // 2
		0x0030, 0x0031, 0x0032, 0x0033, 0x0034, 0x0035, 0x0036, 0x0037, 0x0038, 0x0039, 0x003a, 0x003b, 0x003c, 0x003d, 0x003e, 0x003f, // 3
		0x0040, 0x0041, 0x0042, 0x0043, 0x0044, 0x0045, 0x0046, 0x0047, 0x0048, 0x0049, 0x004a, 0x004b, 0x004c, 0x004d, 0x004e, 0x004f, // 4
		0x0050, 0x0051, 0x0052, 0x0053, 0x0054, 0x0055, 0x0056, 0x0057, 0x0058, 0x0059, 0x005a, 0x005b, 0x005c, 0x005d, 0x005e, 0x005f, // 5
		0x0060, 0x0061, 0x0062, 0x0063, 0x0064, 0x0065, 0x0066, 0x0067, 0x0068, 0x0069, 0x006a, 0x006b, 0x006c, 0x006d, 0x006e, 0x006f, // 6
		0x0070, 0x0071, 0x0072, 0x0073, 0x0074, 0x0075, 0x0076, 0x0077, 0x0078, 0x0079, 0x007a, 0x007b, 0x007c, 0x007d, 0x007e, 0x0000, // 7
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, // 8
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, // 9
		0x00a0, 0x201d, 0x00a2, 0x00a3, 0x00a4, 0x201e, 0x00a6, 0x00a7, 0x00d8, 0x00a9, 0x0156, 0x00ab, 0x00ac, 0x00ad, 0x00ae, 0x00c6, // A
		0x00b0, 0x00b1, 0x00b2, 0x00b3, 0x201c, 0x00b5, 0x00b6, 0x00b7, 0x00f8, 0x00b9, 0x0157, 0x00bb, 0x00bc, 0x00bd, 0x00be, 0x00e6, // B
		0x0104, 0x012e, 0x0100, 0x0106, 0x00c4, 0x00c5, 0x0118, 0x0112, 0x010c, 0x00c9, 0x0179, 0x0116, 0x0122, 0x0136, 0x012a, 0x013b, // C
		0x0160, 0x0143, 0x0145, 0x00d3, 0x014c, 0x00d5, 0x00d6, 0x00d7, 0x0172, 0x0141, 0x015a, 0x016a, 0x00dc, 0x017b, 0x017d, 0x00df, // D
		0x0105, 0x012f, 0x0101, 0x0107, 0x00e4, 0x00e5, 0x0119, 0x0113, 0x010d, 0x00e9, 0x017a, 0x0117, 0x0123, 0x0137, 0x012b, 0x013c, // E
		0x0161, 0x0144, 0x0146, 0x00f3, 0x014d, 0x00f5, 0x00f6, 0x00f7, 0x0173, 0x0142, 0x015b, 0x016b, 0x00fc, 0x017c, 0x017e, 0x2019  // F
	};

	static const uint_least16_t cp8859_14_table[256] = {
		// 0	1		2		3		4		5		6		7		8		9		A		B		C		D		E		F 2nd nibble
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, // 0 1st nibble
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, // 1 
		0x0020, 0x0021, 0x0022, 0x0023, 0x0024, 0x0025, 0x0026, 0x0027, 0x0028, 0x0029, 0x002a, 0x002b, 0x002c, 0x002d, 0x002e, 0x002f, // 2
		0x0030, 0x0031, 0x0032, 0x0033, 0x0034, 0x0035, 0x0036, 0x0037, 0x0038, 0x0039, 0x003a, 0x003b, 0x003c, 0x003d, 0x003e, 0x003f, // 3
		0x0040, 0x0041, 0x0042, 0x0043, 0x0044, 0x0045, 0x0046, 0x0047, 0x0048, 0x0049, 0x004a, 0x004b, 0x004c, 0x004d, 0x004e, 0x004f, // 4
		0x0050, 0x0051, 0x0052, 0x0053, 0x0054, 0x0055, 0x0056, 0x0057, 0x0058, 0x0059, 0x005a, 0x005b, 0x005c, 0x005d, 0x005e, 0x005f, // 5
		0x0060, 0x0061, 0x0062, 0x0063, 0x0064, 0x0065, 0x0066, 0x0067, 0x0068, 0x0069, 0x006a, 0x006b, 0x006c, 0x006d, 0x006e, 0x006f, // 6
		0x0070, 0x0071, 0x0072, 0x0073, 0x0074, 0x0075, 0x0076, 0x0077, 0x0078, 0x0079, 0x007a, 0x007b, 0x007c, 0x007d, 0x007e, 0x0000, // 7
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, // 8
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, // 9		
		0x00a0, 0x1e02, 0x1e03, 0x00a3, 0x010a, 0x010b, 0x1e0a, 0x00a7, 0x1e80, 0x00a9, 0x1e82, 0x1e0b, 0x1ef2, 0x00ad, 0x00ae, 0x0178, // A
		0x1e1e, 0x1e1f, 0x0120, 0x0121, 0x1e40, 0x1e41, 0x00b6, 0x1e56, 0x1e81, 0x1e57, 0x1e83, 0x1e60, 0x1ef3, 0x1e84, 0x1e85, 0x1e61, // B
		0x00c0, 0x00c1, 0x00c2, 0x00c3, 0x00c4, 0x00c5, 0x00c6, 0x00c7, 0x00c8, 0x00c9, 0x00ca, 0x00cb, 0x00cc, 0x00cd, 0x00ce, 0x00cf, // C
		0x0174, 0x00d1, 0x00d2, 0x00d3, 0x00d4, 0x00d5, 0x00d6, 0x1e6a, 0x00d8, 0x00d9, 0x00da, 0x00db, 0x00dc, 0x00dd, 0x0176, 0x00dd, // D
		0x00e0, 0x00e1, 0x00e2, 0x00e3, 0x00e4, 0x00e5, 0x00e6, 0x00e7, 0x00e8, 0x00e9, 0x00ea, 0x00eb, 0x00ec, 0x00ed, 0x00ee, 0x00ef, // E
		0x0175, 0x00f1, 0x00f2, 0x00f3, 0x00f4, 0x00f5, 0x00f6, 0x1e6b, 0x00f8, 0x00f9, 0x00fa, 0x00fb, 0x00fc, 0x00fd, 0x0177, 0x00ff  // F
	};

	static const uint_least16_t cp8859_15_table[256] = {
		// 0	1		2		3		4		5		6		7		8		9		A		B		C		D		E		F 2nd nibble
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, // 0 1st nibble
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, // 1 
		0x0020, 0x0021, 0x0022, 0x0023, 0x0024, 0x0025, 0x0026, 0x0027, 0x0028, 0x0029, 0x002a, 0x002b, 0x002c, 0x002d, 0x002e, 0x002f, // 2
		0x0030, 0x0031, 0x0032, 0x0033, 0x0034, 0x0035, 0x0036, 0x0037, 0x0038, 0x0039, 0x003a, 0x003b, 0x003c, 0x003d, 0x003e, 0x003f, // 3
		0x0040, 0x0041, 0x0042, 0x0043, 0x0044, 0x0045, 0x0046, 0x0047, 0x0048, 0x0049, 0x004a, 0x004b, 0x004c, 0x004d, 0x004e, 0x004f, // 4
		0x0050, 0x0051, 0x0052, 0x0053, 0x0054, 0x0055, 0x0056, 0x0057, 0x0058, 0x0059, 0x005a, 0x005b, 0x005c, 0x005d, 0x005e, 0x005f, // 5
		0x0060, 0x0061, 0x0062, 0x0063, 0x0064, 0x0065, 0x0066, 0x0067, 0x0068, 0x0069, 0x006a, 0x006b, 0x006c, 0x006d, 0x006e, 0x006f, // 6
		0x0070, 0x0071, 0x0072, 0x0073, 0x0074, 0x0075, 0x0076, 0x0077, 0x0078, 0x0079, 0x007a, 0x007b, 0x007c, 0x007d, 0x007e, 0x0000, // 7
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, // 8
		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, // 9	

		0x00a0, 0x00a1, 0x00a2, 0x00a3, 0x20ac, 0x00a5, 0x0160, 0x00a7, 0x0161, 0x00a9, 0x00aa, 0x00ab, 0x00ac, 0x00ad, 0x00ae, 0x00af, // A
		0x00b0, 0x00b1, 0x00b2, 0x00b3, 0x017d, 0x00b5, 0x00b6, 0x00b7, 0x017e, 0x00b9, 0x00ba, 0x00bb, 0x0152, 0x0153, 0x0178, 0x00bf, // B
		0x00c0, 0x00c1, 0x00c2, 0x00c3, 0x00c4, 0x00c5, 0x00c6, 0x00c7, 0x00c8, 0x00c9, 0x00ca, 0x00cb, 0x00cc, 0x00cd, 0x00ce, 0x00cf, // C
		0x00d0, 0x00d1, 0x00d2, 0x00d3, 0x00d4, 0x00d5, 0x00d6, 0x00d7, 0x00d8, 0x00d9, 0x00da, 0x00db, 0x00dc, 0x00dd, 0x00de, 0x00df, // D
		0x00e0, 0x00e1, 0x00e2, 0x00e3, 0x00e4, 0x00e5, 0x00e6, 0x00e7, 0x00e8, 0x00e9, 0x00ea, 0x00eb, 0x00ec, 0x00ed, 0x00ee, 0x00ef, // E
		0x00f0, 0x00f1, 0x00f2, 0x00f3, 0x00f4, 0x00f5, 0x00f6, 0x00f7, 0x00f8, 0x00f9, 0x00fa, 0x00fb, 0x00fc, 0x00fd, 0x00fe, 0x00ff  // F
	};

}

template<class span_reader = void>
class string_reader
{
public:
	typedef std::pair<bool, std::string> element_type;

private:
	static std::string emphasis_on_char;
	static std::string emphasis_off_char;
	static std::string linebreak_char;

	
	static void add_utf8_by_code(const uint_fast32_t cc, std::string& s) {
		if (cc < 0x80) {
			s.push_back(static_cast<char>(cc));
		}
		else
			if (cc < 0x800) {
				s.push_back(static_cast<const char>((cc >> 6) | 0xc0));
				s.push_back(static_cast<const char>((cc & 0x3f) | 0x80));
			}
			else
				if (cc < 0x10000) {
					s.push_back(static_cast<const char>((cc >> 12) | 0xe0));
					s.push_back(static_cast<const char>(((cc >> 6) & 0x3f) | 0x80));
					s.push_back(static_cast<const char>((cc & 0x3f) | 0x80));
				}
				else
					if (cc < 0x110000) {
						s.push_back(static_cast<const char>((cc >> 18) | 0xf0));
						s.push_back(static_cast<const char>(((cc >> 12) & 0x3f) | 0x80));
						s.push_back(static_cast<const char>(((cc >> 6) & 0x3f) | 0x80));
						s.push_back(static_cast<const char>((cc & 0x3f) | 0x80));
					}
	}

	static bool add_special_characters(const uint_fast32_t cc, std::string& s) {
		if (cc == 0x86)
			s += emphasis_on_char;
		else if (cc == 0x87)
			s += emphasis_off_char;
		else if (cc == 0x8a)
			s += linebreak_char;
		else
			return false;
		return true;
	}

	static element_type convert_cp_to_utf8(gsl::span<const char> data, gsl::span<const uint_least16_t> codepage) {
		Expects(codepage.size() == 256);

		std::string s;
		for (auto v : data) {
			unsigned char cc = static_cast<unsigned char> (v);
			if (!add_special_characters(cc, s))
				add_utf8_by_code(codepage[cc], s);
		}
		return std::make_pair(true, s);
	}

	static element_type cp6937(gsl::span<const char> data) { return convert_cp_to_utf8(data, cp6937_table); }
	static element_type cp8859_5(gsl::span<const char> data) { return convert_cp_to_utf8(data, cp8859_5_table); }
	static element_type cp8859_6(gsl::span<const char> data) { return convert_cp_to_utf8(data, cp8859_6_table); }
	static element_type cp8859_7(gsl::span<const char> data) { return convert_cp_to_utf8(data, cp8859_7_table); }
	static element_type cp8859_8(gsl::span<const char> data) { return convert_cp_to_utf8(data, cp8859_8_table); }
	static element_type cp8859_9(gsl::span<const char> data) { return convert_cp_to_utf8(data, cp8859_9_table); }
	static element_type cp8859_10(gsl::span<const char> data) { return convert_cp_to_utf8(data, cp8859_10_table); }
	static element_type cp8859_11(gsl::span<const char> data) { return convert_cp_to_utf8(data, cp8859_11_table); }
	static element_type cp8859_13(gsl::span<const char> data) { return convert_cp_to_utf8(data, cp8859_13_table); }
	static element_type cp8859_14(gsl::span<const char> data) { return convert_cp_to_utf8(data, cp8859_14_table); }
	static element_type cp8859_15(gsl::span<const char> data) { return convert_cp_to_utf8(data, cp8859_15_table); }

public:

	element_type operator()(gsl::span<const char> data, size_t index = 0) const
	{
		return at(data, index);
	}

	static element_type at(gsl::span<const char> data, size_t index = 0)
	{
		// is data aligned?
		bool same = std::is_same<span_reader, void>::value;
		Expects(!same);

		data = span_reader::at(data, index);
		if (data.size() == 0) return std::make_pair(true, "");

		if (static_cast<uint_fast8_t>(data[0]) >= 0x20)
			return cp6937(data); // no identifier

		switch (static_cast<uint_fast8_t>(data[0]))
		{
		case 0x00: return std::make_pair(false, u8"Data error, invalid codepage 0x00.");
		case 0x01: return cp8859_5(data.subspan(1));
		case 0x02: return cp8859_6(data.subspan(1));
		case 0x03: return cp8859_7(data.subspan(1));
		case 0x04: return cp8859_8(data.subspan(1));
		case 0x05: return cp8859_9(data.subspan(1));
		case 0x06: return cp8859_10(data.subspan(1));
		case 0x07: return cp8859_11(data.subspan(1));
			// 0x08 is reserved
		case 0x09: return cp8859_13(data.subspan(1));
		case 0x0a: return cp8859_14(data.subspan(1));
		case 0x0b: return cp8859_15(data.subspan(1));
			// 0x0c to 0x0f reserved
		case 0x10: {
			if (data.size() < 3) return std::make_pair(false, u8"Data error, data length not plausible.");
			if (data[1] != 0) return std::make_pair(false, u8"Reserved codepage, update decoder.");
			switch (static_cast<uint_fast8_t>(data[2]))
			{
				// 0x00 is reserved
			case 0x01: return std::make_pair(false, u8"[cp8859_1 NA]"); // TODO
			case 0x02: return std::make_pair(false, u8"[cp8859_2 NA]"); // TODO
			case 0x03: return std::make_pair(false, u8"[cp8859_3 NA]"); // TODO
			case 0x04: return std::make_pair(false, u8"[cp8859_4 NA]"); // TODO

			case 0x05: return cp8859_5(data.subspan(3));
			case 0x06: return cp8859_6(data.subspan(3));
			case 0x07: return cp8859_7(data.subspan(3));
			case 0x08: return cp8859_8(data.subspan(3));
			case 0x09: return cp8859_9(data.subspan(3));
			case 0x0a: return cp8859_10(data.subspan(3));
			case 0x0b: return cp8859_11(data.subspan(3));
				// 0x0c is reserved
			case 0x0d: return cp8859_13(data.subspan(3));
			case 0x0e: return cp8859_14(data.subspan(3));
			case 0x0f: return cp8859_15(data.subspan(3));
				// 0x10 to 0xff is reserved
			default:
				return std::make_pair(false, u8"Reserved codepage, update decoder.");
			}
		}
		case 0x11: return std::make_pair(false, u8"[Coding 0x11 NA]");
			// The standard does not define the character coding
			// it only states to use the basic multilingual plane 
			// - 16 bit words?
		case 0x12: return std::make_pair(false, u8"[Korean Character Set NA]"); // TODO
		case 0x13: return std::make_pair(false, u8"[Simplified Chinese Characters NA]"); // TODO
		case 0x14: return std::make_pair(false, u8"[Traditional Chinese NA]"); // TODO
		case 0x15: // utf8
			return std::make_pair(true, string(data.data(), data.size()));
			// 0x16 to 0x1e reserved
		case 0x1f: {			
			// company defined encodings
			uint_fast8_t encoding_type_id = data[1];
			return std::make_pair(false, u8"Private codepage " + std::to_string(encoding_type_id) + " not available.");
		}
		default:
			return std::make_pair(false, u8"Reserved codepage, update decoder.");
		}

	}

	static void emphasis_on(std::string utf8) { emphasis_on_char = utf8; }
	static void emphasis_off(std::string utf8) { emphasis_off_char = utf8; }
	static void linebreak(std::string utf8) { linebreak_char = utf8; }

};

template< class span_reader >
std::string string_reader<span_reader>::emphasis_on_char = u8"";
template< class span_reader >
std::string string_reader<span_reader>::emphasis_off_char = u8"";
template< class span_reader >
std::string string_reader<span_reader>::linebreak_char = u8"\n";

}

